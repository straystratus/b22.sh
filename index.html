<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>b22.sh</title>
  <style>
    body {
      background-color: #000000;
      color: #87CEEB;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 20px;
      height: 100vh;
      overflow: hidden;
    }
    #terminal {
      max-width: 800px;
      margin: auto;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #history-container {
      overflow-y: auto;
      flex-grow: 1;
      display: flex;
      flex-direction: column-reverse;
    }
    .prompt {
      color: #00BFFF;
    }
    .command {
      color: #87CEEB;
    }
    .output {
      white-space: pre-wrap;
      margin-bottom: 10px;
      word-wrap: break-word;
    }
    #input-line {
      display: flex;
      align-items: center;
      flex-shrink: 0;
    }
    #command-input {
      background: transparent;
      border: none;
      color: #87CEEB;
      font-family: inherit;
      font-size: 16px;
      width: 100%;
      outline: none;
      margin-left: 5px;
      padding: 0;
      flex: 1;
    }
    .dir {
      color: #87CEEB;
    }
    .file {
      color: #B0E0E6;
    }
    a {
      color: #00BFFF;
      text-decoration: underline;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="history-container">
      <div id="history"></div>
      <div class="output">Type 'help' for available commands.</div>
    </div>
    <div id="input-line">
      <span class="prompt" id="prompt">deus@machina:~$ </span>
      <input type="text" id="command-input" autofocus autocomplete="off" spellcheck="false">
    </div>
  </div>

  <script>
    function linkify(text) {
      return text.replace(/(https?:\/\/[^\s]+)|(GitHub: @[^\s]+)/g, function(match) {
        if (match.startsWith('http')) {
          return `<a href="${match}" target="_blank">${match}</a>`;
        } else if (match.startsWith('GitHub')) {
          const username = match.split('@')[1];
          return `GitHub: <a href="https://github.com/straystratus" target="_blank">@straystratus</a>`;
        }
        return match;
      });
    }

    const fs = {
      'aboutme': {
        'contacts': 'Email: all set\nGitHub: @straystratus\nX: @stratustm',
        'stratus': 'hey ! im actively working on zksnarks, blockchain developement and C, of course.\ni like birds and tea, a lot.',
        'readings':
	  `- <a href="http://www.catb.org/esr/faqs/hacker-howto.html#hacker_already" target="_blank">How To Become A Hacker</a>\n` +
	  `- <a href="https://www.feynmanlectures.caltech.edu/" target="_blank">The Feynman Lectures on Physics</a>\n` +
	  `- <a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf" target="_blank">cpumemory</a>\n` +
	  `- <a href="https://oceanofpdf.com/authors/lukas-hozda/pdf-building-bitcoin-in-rust-download/" target="_blank">Building Bitcoin in Rust</a>`
      },
      'projects': {
        'stdex': 'my own decentralized exchange',
        'shiro': 'no comments',
        'manifesto': 'photon extension, see how many (buys/sells)/wallet',
        'gravitas': 'no comments',
        'fyf': 'no comments',
      },
      'docs': {
        'readme': '# b22 terminal\n\nweb-based terminal emulator',
        'changelog': '# changelog\n\nv1.0 - Initial release'
      }
    };

    let currentPath = [];
    let commandHistory = [];
    let historyIndex = -1;

    const prompt = document.getElementById('prompt');
    const input = document.getElementById('command-input');
    const historyDiv = document.getElementById('history');
    const historyContainer = document.getElementById('history-container');

    function getCurrentDir() {
      let dir = fs;
      for (let segment of currentPath) {
        if (dir[segment] && typeof dir[segment] === 'object') {
          dir = dir[segment];
        } else {
          return null;
        }
      }
      return dir;
    }

    function resolvePath(inputPath) {
      if (!inputPath) return [...currentPath];

      const isAbsolute = inputPath.startsWith('/');
      const base = isAbsolute ? [] : [...currentPath];
      const segments = inputPath.split('/').filter(Boolean);

      for (let segment of segments) {
        if (segment === '.') continue;
        if (segment === '..') {
          base.pop();
        } else {
          base.push(segment);
        }
      }
      return base;
    }

    function listDirectory(args = []) {
      const path = resolvePath(args[0]);
      let dir = fs;

      for (let segment of path) {
        if (!dir[segment]) return `ls: cannot access '${args[0]}': No such file or directory`;
        dir = dir[segment];
      }

      if (typeof dir !== 'object') return `ls: not a directory`;

      return Object.keys(dir).map(k => `<span class="${typeof dir[k] === 'object' ? 'dir' : 'file'}">${k}</span>`).join('  ');
    }

    function changeDirectory(args) {
      if (args.length === 0) {
        currentPath = [];
        updatePrompt();
        return '';
      }

      const path = resolvePath(args[0]);
      let dir = fs;
      for (let segment of path) {
        if (!dir[segment] || typeof dir[segment] !== 'object') {
          return `cd: ${args[0]}: Not a directory`;
        }
        dir = dir[segment];
      }

      currentPath = path;
      updatePrompt();
      return '';
    }

    function printWorkingDirectory() {
      return '/' + currentPath.join('/');
    }

    function readFile(args) {
      if (args.length === 0) return 'cat: missing file operand';
      const parts = resolvePath(args[0]);
      const file = parts.pop();
      let dir = fs;
      for (let segment of parts) {
        if (!dir[segment]) return `cat: ${args[0]}: No such file or directory`;
        dir = dir[segment];
      }
      if (!dir[file]) return `cat: ${args[0]}: No such file or directory`;
      if (typeof dir[file] === 'object') return `cat: ${args[0]}: Is a directory`;
      return linkify(dir[file]);
    }

    function displayTree() {
      const dir = getCurrentDir();
      if (!dir) return 'tree: cannot access current directory';
      let output = '/' + currentPath.join('/') + '\n';
      function build(node, prefix = '') {
        const keys = Object.keys(node);
        keys.forEach((k, i) => {
          const isLast = i === keys.length - 1;
          output += `${prefix}${isLast ? '└── ' : '├── '}${k}\n`;
          if (typeof node[k] === 'object') build(node[k], prefix + (isLast ? '    ' : '│   '));
        });
      }
      build(dir);
      return output;
    }

    function showHelp() {
      return `Available commands:
  ls [dir]    - list directory contents
  cd [dir]    - change directory
  pwd         - print working directory
  cat <file>        - display file contents
  tree        - show directory tree
  clear       - clear terminal
  help        - show this help`;
    }

    function clearScreen() {
      historyDiv.innerHTML = '';
      return '';
    }

    const commands = {
      ls: listDirectory,
      cd: changeDirectory,
      pwd: printWorkingDirectory,
      cat: readFile,
      tree: displayTree,
      help: showHelp,
      clear: clearScreen
    };

    function executeCommand(line) {
      const trimmed = line.trim();
      if (!trimmed) return '';
      const [cmd, ...args] = trimmed.split(/\s+/);
      if (commands[cmd]) {
        try {
          return commands[cmd](args);
        } catch {
          return `${cmd}: error executing command`;
        }
      }
      return `${cmd}: command not found`;
    }

    function updatePrompt() {
      prompt.textContent = `deus@machina:/${currentPath.join('/')}$ `;
    }

    function addToHistory(command, output) {
      const cmdDiv = document.createElement('div');
      cmdDiv.innerHTML = `<span class="prompt">${prompt.textContent}</span><span class="command">${command}</span>`;
      historyDiv.appendChild(cmdDiv);
      if (output) {
        const outDiv = document.createElement('div');
        outDiv.className = 'output';
        outDiv.innerHTML = output;
        historyDiv.appendChild(outDiv);
      }
      historyContainer.scrollTop = historyContainer.scrollHeight;
    }

    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        const command = input.value.trim();
        if (command) {
          commandHistory.push(command);
          historyIndex = commandHistory.length;
          const output = executeCommand(command);
          if (command !== 'clear') {
            addToHistory(command, output);
          } else {
            clearScreen();
          }
          input.value = '';
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.value = commandHistory[historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.value = commandHistory[historyIndex];
        } else {
          historyIndex = commandHistory.length;
          input.value = '';
        }
      }
    });

    document.addEventListener('click', function() {
      input.focus();
    });

    window.addEventListener('load', function() {
      input.focus();
    });

    updatePrompt();
  </script>
</body>
</html>
