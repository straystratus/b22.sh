<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>b22.sh</title>
  <style>
    body {
      background-color: #1a1a1a;
      color: #f0f0f0;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }
    #terminal {
      max-width: 800px;
      margin: auto;
    }
    .prompt {
      color: #4CAF50;
    }
    .command {
      color: #64B5F6;
    }
    .output {
      white-space: pre-wrap;
      margin-bottom: 10px;
      word-wrap: break-word;
    }
    #input-line {
      display: flex;
      align-items: center;
    }
    #command-input {
      background: transparent;
      border: none;
      color: #f0f0f0;
      font-family: inherit;
      font-size: 16px;
      width: 100%;
      outline: none;
      margin-left: 5px;
      padding: 0;
      flex: 1;
    }
    .dir {
      color: #4FC3F7;
    }
    .file {
      color: #FFD54F;
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div class="output">
Type 'help' for available commands.</div>
    <div id="history"></div>
    <div id="input-line">
      <span class="prompt" id="prompt">deus@machina:~$ </span>
      <input type="text" id="command-input" autofocus autocomplete="off" spellcheck="false">
    </div>
  </div>

  <script>
    const fs = {
      'aboutme': {
        'contacts.txt': 'Email: contact@b22.dev\nGitHub: @b22terminal\nLinkedIn: /in/b22dev',
        'bio.md': '# About Me\n\nPassionate developer creating terminal interfaces.',
        'readings.md': '## Reading List\n- Clean Code\n- The Pragmatic Programmer'
      },
      'projects': {
        'p1': 'Terminal emulator project',
        'p2': 'Web-based filesystem',
        'p3': 'CLI tools collection',
        'p4': 'Documentation generator',
        'p5': 'Automation scripts',
        'p6': 'Experimental prototypes'
      },
      'docs': {
        'readme.md': '# B22 Terminal\n\nWeb-based terminal emulator',
        'changelog.md': '# Changelog\n\nv1.0 - Initial release'
      }
    };

    let currentPath = [];
    let commandHistory = [];
    let historyIndex = -1;

    const prompt = document.getElementById('prompt');
    const input = document.getElementById('command-input');
    const historyDiv = document.getElementById('history');

    function getCurrentDir() {
      let dir = fs;
      for (let segment of currentPath) {
        if (dir[segment] && typeof dir[segment] === 'object') {
          dir = dir[segment];
        } else {
          return null;
        }
      }
      return dir;
    }

    function resolvePath(inputPath) {
      if (!inputPath) return [...currentPath];

      const isAbsolute = inputPath.startsWith('/');
      const base = isAbsolute ? [] : [...currentPath];
      const segments = inputPath.split('/').filter(Boolean);

      for (let segment of segments) {
        if (segment === '.') continue;
        if (segment === '..') {
          base.pop();
        } else {
          base.push(segment);
        }
      }
      return base;
    }

    function listDirectory(args = []) {
      const path = resolvePath(args[0]);
      let dir = fs;

      for (let segment of path) {
        if (!dir[segment]) return `ls: cannot access '${args[0]}': No such file or directory`;
        dir = dir[segment];
      }

      if (typeof dir !== 'object') return `ls: not a directory`;

      return Object.keys(dir).map(k => `<span class="${typeof dir[k] === 'object' ? 'dir' : 'file'}">${k}</span>`).join('  ');
    }

    function changeDirectory(args) {
      if (args.length === 0) {
        currentPath = [];
        updatePrompt();
        return '';
      }

      const path = resolvePath(args[0]);
      let dir = fs;
      for (let segment of path) {
        if (!dir[segment] || typeof dir[segment] !== 'object') {
          return `cd: ${args[0]}: Not a directory`;
        }
        dir = dir[segment];
      }

      currentPath = path;
      updatePrompt();
      return '';
    }

    function printWorkingDirectory() {
      return '/' + currentPath.join('/');
    }

    function readFile(args) {
      if (args.length === 0) return 'cat: missing file operand';
      const parts = resolvePath(args[0]);
      const file = parts.pop();
      let dir = fs;
      for (let segment of parts) {
        if (!dir[segment]) return `cat: ${args[0]}: No such file or directory`;
        dir = dir[segment];
      }
      if (!dir[file]) return `cat: ${args[0]}: No such file or directory`;
      if (typeof dir[file] === 'object') return `cat: ${args[0]}: Is a directory`;
      return dir[file];
    }

    function displayTree() {
      const dir = getCurrentDir();
      if (!dir) return 'tree: cannot access current directory';
      let output = '/' + currentPath.join('/') + '\n';
      function build(node, prefix = '') {
        const keys = Object.keys(node);
        keys.forEach((k, i) => {
          const isLast = i === keys.length - 1;
          output += `${prefix}${isLast ? '└── ' : '├── '}${k}\n`;
          if (typeof node[k] === 'object') build(node[k], prefix + (isLast ? '    ' : '│   '));
        });
      }
      build(dir);
      return output;
    }

    function showHelp() {
      return `Available commands:
  ls [dir]    - list directory contents
  cd [dir]    - change directory
  pwd         - print working directory
  cat <file>  - display file contents
  tree        - show directory tree
  clear       - clear terminal
  help        - show this help`;
    }

    function clearScreen() {
      historyDiv.innerHTML = '';
      return '';
    }

    const commands = {
      ls: listDirectory,
      cd: changeDirectory,
      pwd: printWorkingDirectory,
      cat: readFile,
      tree: displayTree,
      help: showHelp,
      clear: clearScreen
    };

    function executeCommand(line) {
      const trimmed = line.trim();
      if (!trimmed) return '';
      const [cmd, ...args] = trimmed.split(/\s+/);
      if (commands[cmd]) {
        try {
          return commands[cmd](args);
        } catch {
          return `${cmd}: error executing command`;
        }
      }
      return `${cmd}: command not found`;
    }

    function updatePrompt() {
      prompt.textContent = `deus@machina:/${currentPath.join('/')}$ `;
    }

    function addToHistory(command, output) {
      const cmdDiv = document.createElement('div');
      cmdDiv.innerHTML = `<span class="prompt">${prompt.textContent}</span><span class="command">${command}</span>`;
      historyDiv.appendChild(cmdDiv);
      if (output) {
        const outDiv = document.createElement('div');
        outDiv.className = 'output';
        outDiv.innerHTML = output;
        historyDiv.appendChild(outDiv);
      }
      window.scrollTo(0, document.body.scrollHeight);
    }

    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const command = input.value.trim();
        if (command) {
          commandHistory.push(command);
          historyIndex = commandHistory.length;
          const output = executeCommand(command);
          if (command !== 'clear') {
            addToHistory(command, output);
          } else {
            clearScreen();
          }
          input.value = '';
          // Recentrer le curseur après exécution
          setTimeout(() => {
            input.focus();
            input.selectionStart = input.selectionEnd = input.value.length;
          }, 0);
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) {
          input.value = commandHistory[--historyIndex];
          // Positionner le curseur à la fin
          setTimeout(() => {
            input.selectionStart = input.selectionEnd = input.value.length;
          }, 0);
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          input.value = commandHistory[++historyIndex];
          // Positionner le curseur à la fin
          setTimeout(() => {
            input.selectionStart = input.selectionEnd = input.value.length;
          }, 0);
        } else {
          input.value = '';
          historyIndex = commandHistory.length;
        }
      }
    });

    document.addEventListener('click', () => {
      input.focus();
      // Positionner le curseur à la fin lors d'un clic
      setTimeout(() => {
        input.selectionStart = input.selectionEnd = input.value.length;
      }, 0);
    });

    // Positionnement initial du curseur
    window.addEventListener('load', () => {
      input.focus();
      setTimeout(() => {
        input.selectionStart = input.selectionEnd = input.value.length;
      }, 0);
    });

    updatePrompt();
  </script>
</body>
</html>
