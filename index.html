<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>b22.sh</title>
  <link rel="icon" type="image/ico" href="favicon.ico">
  <style>
    body {
      background: #000;
      color: #87CEEB;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 20px;
      height: 100vh;
      overflow: hidden;
    }
    #terminal {
      max-width: 800px;
      margin: auto;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #history-container {
      overflow-y: auto;
      flex: 1;
      display: flex;
      flex-direction: column-reverse;
    }
    .prompt { color: #00BFFF; }
    .command { color: #87CEEB; }
    .output {
      white-space: pre-wrap;
      margin-bottom: 10px;
      word-wrap: break-word;
    }
    #input-line {
      display: flex;
      align-items: center;
      flex-shrink: 0;
    }
    #command-input {
      background: transparent;
      border: none;
      color: #87CEEB;
      font-family: inherit;
      font-size: 16px;
      width: 100%;
      outline: none;
      margin-left: 5px;
      padding: 0;
      flex: 1;
    }
    .dir { color: #0f97cc; }
    .file { color: #B0E0E6; }
    a { color: #00BFFF; text-decoration: underline; cursor: pointer; }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="history-container">
      <div id="history"></div>
      <div class="output">Type 'help' for available commands.</div>
    </div>
    <div id="input-line">
      <span class="prompt" id="prompt">deus@machina:~$ </span>
      <input type="text" id="command-input" autofocus autocomplete="off" spellcheck="false">
    </div>
  </div>
  <script>
    const fs = {
      aboutme: {
        contacts:
          `<a href="mailto:straystratus@gmail.com">email</a>\n` +
          `<a href="https://github.com/straystratus">github</a>\n` +
          `<a href="https://x.com/stratustm">twitter</a>`,
        stratus: "hey ! im stratus. im actively working on zksnarks, ethereum developement and C, of course.\ni like birds and tea, a lot.",
        readings:
          `- <a href="http://www.catb.org/esr/faqs/hacker-howto.html#hacker_already" target="_blank">How To Become A Hacker</a>\n` +
          `- <a href="https://www.feynmanlectures.caltech.edu/" target="_blank">The Feynman Lectures on Physics</a>\n` +
          `- <a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf" target="_blank">What Every Programmer Should Know About Memory</a>\n` +
          `- <a href="https://web.mit.edu/6.001/6.037/sicp.pdf" target="_blank">SICP</a>\n` +
          `- <a href="https://oceanofpdf.com/authors/lukas-hozda/pdf-building-bitcoin-in-rust-download/" target="_blank">Building Bitcoin in Rust</a>`
      },
      projects: {
        stdex: 'my own decentralized exchange\n<a href="https://github.com/straystratus/stdex" target="_blank">check</a>',
        shiro: 'no comments',
        manifesto: 'photon extension, see (buys/sells)/wallet\n<a href="https://github.com/straystratus/manifesto" target="_blank">check</a>',
        gravitas: 'no comments',
        fyf: 'no comments'
      },
      resources: {
        websites:
          `- <a href="https://vitalik.eth.limo/" target="_blank">Vitalik Buterin</a>\n` +
          `- <a href="https://beej.us/guide/" target="_blank">Beej's Guides</a>\n` +
          `- <a href="https://michaelneuder.github.io/index.html" target="_blank">Mike Neuder</a>\n` +
          `- <a href="https://www.furidamu.org/" target="_blank">Julian Schrittwieser</a>\n` +
          `- <a href="https://near.blog/" target="_blank">near.blog</a>\n` +
          `- <a href="https://riemani.ca/" target="_blank">mani</a>\n`,
      },
    };

    let currentPath = [];
    let commandHistory = [];
    let historyIndex = -1;

    const prompt = document.getElementById('prompt');
    const input = document.getElementById('command-input');
    const historyDiv = document.getElementById('history');
    const historyContainer = document.getElementById('history-container');

    function getCurrentDir() {
      return currentPath.reduce(
        (dir, segment) => (dir && typeof dir[segment] === "object" ? dir[segment] : null), fs
      );
    }

    function resolvePath(pathStr = "") {
      const segments = pathStr.split('/').filter(Boolean);
      let base = pathStr.startsWith('/') ? [] : [...currentPath];
      for (const seg of segments) {
        if (seg === '.') continue;
        if (seg === '..') base.pop();
        else base.push(seg);
      }
      return base;
    }

    function listDirectory([dirArg]) {
      const path = resolvePath(dirArg || "");
      let dir = fs;
      for (const segment of path) {
        if (!dir[segment]) return `ls: cannot access '${dirArg}': No such file or directory`;
        dir = dir[segment];
      }
      if (typeof dir !== 'object') return `ls: not a directory`;
      return Object.entries(dir).map(([k, v]) =>
        `<span class="${typeof v === 'object' ? 'dir' : 'file'}">${k}</span>`
      ).join('  ');
    }

    function changeDirectory([dirArg]) {
      if (!dirArg) {
        currentPath = [];
        updatePrompt();
        return '';
      }
      const path = resolvePath(dirArg);
      let dir = fs;
      for (const segment of path) {
        if (!dir[segment] || typeof dir[segment] !== 'object')
          return `cd: ${dirArg}: Not a directory`;
        dir = dir[segment];
      }
      currentPath = path;
      updatePrompt();
      return '';
    }

    function printWorkingDirectory() {
      return '/' + currentPath.join('/');
    }

    function readFile([filePath]) {
      if (!filePath) return 'cat: missing file operand';
      const parts = resolvePath(filePath);
      const file = parts.pop();
      let dir = fs;
      for (const segment of parts) {
        if (!dir[segment]) return `cat: ${filePath}: No such file or directory`;
        dir = dir[segment];
      }
      if (!dir[file]) return `cat: ${filePath}: No such file or directory`;
      if (typeof dir[file] === 'object') return `cat: ${filePath}: Is a directory`;
      return dir[file];
    }

    function displayTree() {
      const dir = getCurrentDir();
      if (!dir) return 'tree: cannot access current directory';
      let output = '/' + currentPath.join('/') + '\n';
      function build(node, prefix = '') {
        const keys = Object.keys(node);
        keys.forEach((k, i) => {
          const isLast = i === keys.length - 1;
          output += `${prefix}${isLast ? '└── ' : '├── '}${k}\n`;
          if (typeof node[k] === 'object') build(node[k], prefix + (isLast ? '    ' : '│   '));
        });
      }
      build(dir);
      return output;
    }

    function showHelp() {
      return `Available commands:
ls [dir]    - list directory contents
cd [dir]    - change directory
pwd         - print working directory
cat <file>        - display file contents
tree        - show directory tree
clear       - clear terminal
help        - show this help`;
    }

    function clearScreen() {
      historyDiv.innerHTML = '';
      return '';
    }

    function printAsciiLetterByLetter(ascii, callback) {
      const historyDiv = document.getElementById('history');
      let i = 0;
      let outputDiv = document.createElement('div');
      outputDiv.className = 'output';
      outputDiv.style.whiteSpace = 'pre';
      historyDiv.appendChild(outputDiv);

      function printNext() {
        if (i < ascii.length) {
          outputDiv.textContent += ascii[i];
          i++;
          setTimeout(printNext, 7); // vitesse (en ms), ajuste pour + rapide/lent
        } else if (callback) {
          callback();
        }
        historyDiv.scrollTop = historyDiv.scrollHeight;
      }
    printNext();
    }

    const commands = {
      ls: listDirectory,
      cd: changeDirectory,
      pwd: printWorkingDirectory,
      cat: readFile,
      tree: displayTree,
      help: showHelp,
      clear: clearScreen,
      b22: () => {
        return null;
      }
    };

    function executeCommand(line) {
      const trimmed = line.trim();
      if (!trimmed) return '';
      const [cmd, ...args] = trimmed.split(/\s+/);
      if (cmd === 'b22') {
        const ascii = 
      `       ░▒▓█▓▒         ░▒▓███████▓▒░  ░▒▓███████▓▒░  
       ░▒▓█▓▒                ░▒▓█▓▒░        ░▒▓█▓▒░ 
       ░▒▓█▓▒                ░▒▓█▓▒░        ░▒▓█▓▒░ 
       ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓██████▓▒░  
       ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░        ░▒▓█▓▒░        
       ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░        ░▒▓█▓▒░        
       ░▒▓███████▓▒░  ░▒▓████████▓▒░ ░▒▓████████▓▒░`;

        addToHistory(trimmed, '');
        printAsciiLetterByLetter(ascii);
        return '';
      }

      if (commands[cmd]) {
        try { return commands[cmd](args); }
        catch { return `${cmd}: error executing command`; }
      }
      return `${cmd}: command not found`;
    }

    function updatePrompt() {
      prompt.textContent = `deus@machina:/${currentPath.join('/')}$ `;
    }

    function addToHistory(command, output) {
      const cmdDiv = document.createElement('div');
      cmdDiv.innerHTML = `<span class="prompt">${prompt.textContent}</span><span class="command">${command}</span>`;
      historyDiv.appendChild(cmdDiv);
      if (output) {
        const outDiv = document.createElement('div');
        outDiv.className = 'output';
        outDiv.innerHTML = output;
        historyDiv.appendChild(outDiv);
      }
      historyContainer.scrollTop = historyContainer.scrollHeight;
    }

    let autocompleteState = {
      fragment: '',
      context: '',
      matches: [],
      index: 0,
      lastValue: ''
    };

    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        const command = input.value.trim();
        if (command) {
          commandHistory.push(command);
          historyIndex = commandHistory.length;
          const output = executeCommand(command);
          if (command !== 'clear') addToHistory(command, output);
          else clearScreen();
          input.value = '';
        }
        autocompleteState = { fragment: '', context: '', matches: [], index: 0, lastValue: '' }; // reset
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) input.value = commandHistory[--historyIndex];
        autocompleteState = { fragment: '', context: '', matches: [], index: 0, lastValue: '' };
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) input.value = commandHistory[++historyIndex];
        else { historyIndex = commandHistory.length; input.value = ''; }
        autocompleteState = { fragment: '', context: '', matches: [], index: 0, lastValue: '' };
      }
      else if (e.key === 'Tab') {
        e.preventDefault();

        const value = input.value;
        const split = value.trim().split(/\s+/);

        if (split.length === 1) {
          const fragment = split[0];
          if (!fragment) return;
          if (
            autocompleteState.context !== 'command' ||
            autocompleteState.fragment !== fragment ||
            autocompleteState.lastValue !== value
          ) {
            autocompleteState.context = 'command';
            autocompleteState.fragment = fragment;
            autocompleteState.matches = Object.keys(commands).filter(cmd => cmd.startsWith(fragment));
            autocompleteState.index = 0;
            autocompleteState.lastValue = value;
          }
          const matches = autocompleteState.matches;
          if (matches.length === 0) return;
          input.value = matches[autocompleteState.index] + ' ';
          autocompleteState.index = (autocompleteState.index + 1) % matches.length;
          autocompleteState.lastValue = input.value;
        }
        else if (split.length >= 2) {
          const cmd = split[0];
          if (cmd === 'cat') {
            const partial = split[1];
            let dir = getCurrentDir();
            if (!dir) return;
            const files = Object.entries(dir)
              .filter(([k, v]) => typeof v !== 'object')
              .map(([k, v]) => k);
            if (
              autocompleteState.context !== 'cat' ||
              autocompleteState.fragment !== partial ||
              autocompleteState.lastValue !== value
            ) {
              autocompleteState.context = 'cat';
              autocompleteState.fragment = partial;
              autocompleteState.matches = files.filter(f => f.startsWith(partial));
              autocompleteState.index = 0;
              autocompleteState.lastValue = value;
            }
            const matches = autocompleteState.matches;
            if (matches.length === 0) return;
            input.value = cmd + ' ' + matches[autocompleteState.index];
            autocompleteState.index = (autocompleteState.index + 1) % matches.length;
            autocompleteState.lastValue = input.value;
          }
        }
      }
    });
    document.addEventListener('click', () => input.focus());
    window.addEventListener('load', () => input.focus());
    updatePrompt();
  </script>
</body>
</html>
