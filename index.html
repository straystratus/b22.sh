<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>b22.sh</title>
  <link rel="icon" type="image/ico" href="favicon.ico">
  <style>
    :root {
      --bg: #000;
      --fg: #87CEEB;
      --prompt: #00BFFF;
      --dir: #0f97cc;
      --file: #B0E0E6;
    }
    body {
      background: var(--bg);
      color: var(--fg);
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 20px;
      height: 100vh;
      overflow: hidden;
    }
    #terminal {
      max-width: 800px;
      margin: auto;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #history-container {
      overflow-y: auto;
      flex: 1;
      display: flex;
      flex-direction: column-reverse;
    }
    .prompt { color: var(--prompt); }
    .command { color: var(--fg); }
    .output {
      white-space: pre-wrap;
      margin-bottom: 10px;
      word-wrap: break-word;
    }
    #input-line {
      display: flex;
      align-items: center;
      flex-shrink: 0;
    }
    #command-input {
      background: transparent;
      border: none;
      color: var(--fg);
      font-family: inherit;
      font-size: 16px;
      width: 100%;
      outline: none;
      margin-left: 5px;
      padding: 0;
      flex: 1;
    }
    .dir { color: var(--dir); }
    .file { color: var(--file); }
    a { color: var(--prompt); text-decoration: underline; cursor: pointer; }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="history-container">
      <div id="history"></div>
      <div class="output">Type 'help' for available commands.</div>
    </div>
    <div id="input-line">
      <span class="prompt" id="prompt">deus@machina:~$ </span>
      <input type="text" id="command-input" autofocus autocomplete="off" spellcheck="false">
    </div>
  </div>
  <script>
    const THEMES = {
      default: {
        '--bg': '#000',
        '--fg': '#87CEEB',
        '--prompt': '#00BFFF',
        '--dir': '#0f97cc',
        '--file': '#B0E0E6',
      },
      matrix: {
        '--bg': '#111',
        '--fg': '#39FF14',
        '--prompt': '#0f0',
        '--dir': '#29a329',
        '--file': '#99ff99',
      },
      solarized: {
        '--bg': '#002b36',
        '--fg': '#93a1a1',
        '--prompt': '#268bd2',
        '--dir': '#2aa198',
        '--file': '#b58900',
      },
      hacker: {
        '--bg': '#181818',
        '--fg': '#00ffb6',
        '--prompt': '#ff00b6',
        '--dir': '#ffb600',
        '--file': '#00b6ff',
      },
    };
    function setTheme(theme) {
      if (!THEMES[theme]) return;
      Object.entries(THEMES[theme]).forEach(([k, v]) => {
        document.documentElement.style.setProperty(k, v);
      });
      localStorage.setItem('b22_theme', theme);
    }
    const savedTheme = localStorage.getItem('b22_theme') || 'default';
    setTheme(savedTheme);

    const fs = {
      aboutme: {
        contacts:
          `<a href="mailto:straystratus@gmail.com">email</a>\n` +
          `<a href="https://github.com/straystratus">github</a>\n` +
          `<a href="https://x.com/stratustm">twitter</a>`,
        stratus: "hey ! im stratus, but you can call me wheat. im actively working on zksnarks, ethereum developement and C, of course.\ni like birds and tea, a lot.",
        readings:
          `- <a href="http://www.catb.org/esr/faqs/hacker-howto.html#hacker_already" target="_blank">How To Become A Hacker</a>\n` +
          `- <a href="https://www.feynmanlectures.caltech.edu/" target="_blank">The Feynman Lectures on Physics</a>\n` +
          `- <a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf" target="_blank">What Every Programmer Should Know About Memory</a>\n` +
          `- <a href="https://web.mit.edu/6.001/6.037/sicp.pdf" target="_blank">SICP</a>\n` +
          `- <a href="https://oceanofpdf.com/authors/lukas-hozda/pdf-building-bitcoin-in-rust-download/" target="_blank">Building Bitcoin in Rust</a>`
      },
      projects: {
        stdex: 'my own decentralized exchange (only a swap done for now, other projects are prioritized)\n<a href="https://github.com/straystratus/stdex" target="_blank">check</a>',
        shiro: 'no comments',
        manifesto: 'photon extension, see (buys/sells)/wallet\n<a href="https://github.com/straystratus/manifesto" target="_blank">check</a>',
        gravitas: 'no comments',
        fyf: 'no comments'
      },
      resources: {
        websites:
          `- <a href="https://vitalik.eth.limo/" target="_blank">Vitalik Buterin</a>\n` +
          `- <a href="https://beej.us/guide/" target="_blank">Beej's Guides</a>\n` +
          `- <a href="https://michaelneuder.github.io/index.html" target="_blank">Mike Neuder</a>\n` +
          `- <a href="https://www.furidamu.org/" target="_blank">Julian Schrittwieser</a>\n` +
          `- <a href="https://near.blog/" target="_blank">near.blog</a>\n` +
          `- <a href="https://riemani.ca/" target="_blank">mani</a>\n`,
      },
    };

    let currentPath = [];
    let commandHistory = JSON.parse(localStorage.getItem('commandHistory') || '[]');
    let historyIndex = commandHistory.length;

    const PLAYLIST = [
      { name: "01", src: "music/01. Main Menu.mp3" },
      { name: "02", src: "music/02. Theme Shop.mp3" },
      { name: "03", src: "music/03. Friend List.mp3" },
      { name: "04", src: "music/04. Menu 01 (Wii Music).mp3" },
      { name: "05", src: "music/05. Nintendo 3DS Camera - Slideshow (Pop).mp3" },
      { name: "06", src: "music/06. Credits (Wii Play Motion).mp3" },
      { name: "07", src: "music/07. Nintendo 3DS Camera - Slideshow (Pop).mp3" },
      { name: "08", src: "music/kaitenzushi.mp3" }
    ];

    let currentMusicIndex = null;
    let audio = null;

    const prompt = document.getElementById('prompt');
    const input = document.getElementById('command-input');
    const historyDiv = document.getElementById('history');
    const historyContainer = document.getElementById('history-container');

    function getCurrentDir() {
      return currentPath.reduce(
        (dir, segment) => (dir && typeof dir[segment] === "object" ? dir[segment] : null), fs
      );
    }

    function resolvePath(pathStr = "") {
      const segments = pathStr.split('/').filter(Boolean);
      let base = pathStr.startsWith('/') ? [] : [...currentPath];
      for (const seg of segments) {
        if (seg === '.') continue;
        if (seg === '..') base.pop();
        else base.push(seg);
      }
      return base;
    }

    function listDirectory([dirArg]) {
      const path = resolvePath(dirArg || "");
      let dir = fs;
      for (const segment of path) {
        if (!dir[segment]) return `ls: cannot access '${dirArg}': No such file or directory`;
        dir = dir[segment];
      }
      if (typeof dir !== 'object') return `ls: not a directory`;
      return Object.entries(dir).map(([k, v]) =>
        `<span class="${typeof v === 'object' ? 'dir' : 'file'}">${k}</span>`
      ).join('  ');
    }

    function changeDirectory([dirArg]) {
      if (!dirArg) {
        currentPath = [];
        updatePrompt();
        return '';
      }
      const path = resolvePath(dirArg);
      let dir = fs;
      for (const segment of path) {
        if (!dir[segment] || typeof dir[segment] !== 'object')
          return `cd: ${dirArg}: Not a directory`;
        dir = dir[segment];
      }
      currentPath = path;
      updatePrompt();
      return '';
    }

    function printWorkingDirectory() {
      return '/' + currentPath.join('/');
    }

    function readFile([filePath]) {
      if (!filePath) return 'cat: missing file operand';
      const parts = resolvePath(filePath);
      const file = parts.pop();
      let dir = fs;
      for (const segment of parts) {
        if (!dir[segment]) return `cat: ${filePath}: No such file or directory`;
        dir = dir[segment];
      }
      if (!dir[file]) return `cat: ${filePath}: No such file or directory`;
      if (typeof dir[file] === 'object') return `cat: ${filePath}: Is a directory`;
      return dir[file];
    }

    function displayTree() {
      const dir = getCurrentDir();
      if (!dir) return 'tree: cannot access current directory';
      let output = '/' + currentPath.join('/') + '\n';
      function build(node, prefix = '') {
        const keys = Object.keys(node);
        keys.forEach((k, i) => {
          const isLast = i === keys.length - 1;
          output += `${prefix}${isLast ? '└── ' : '├── '}${k}\n`;
          if (typeof node[k] === 'object') build(node[k], prefix + (isLast ? '    ' : '│   '));
        });
      }
      build(dir);
      return output;
    }

    function showHelp() {
      return `Available commands:
ls [dir]     - list directory contents
cd [dir]     - change directory
pwd          - print working directory
cat <file>         - display file contents
tree         - show directory tree
clear        - clear terminal
help         - show this help
theme [name] - change color theme (type 'theme' for list)
music        - play some music !`;
    }

    function clearScreen() {
      historyDiv.innerHTML = '';
      return '';
    }

    function printAsciiLetterByLetter(ascii, callback) {
      const historyDiv = document.getElementById('history');
      let i = 0;
      let outputDiv = document.createElement('div');
      outputDiv.className = 'output';
      outputDiv.style.whiteSpace = 'pre';
      historyDiv.appendChild(outputDiv);

      function printNext() {
        if (i < ascii.length) {
          outputDiv.textContent += ascii[i];
          i++;
          setTimeout(printNext, 7);
        } else if (callback) {
          callback();
        }
        historyDiv.scrollTop = historyContainer.scrollHeight;
      }
      printNext();
    }

    const commands = {
      ls: listDirectory,
      cd: changeDirectory,
      pwd: printWorkingDirectory,
      cat: readFile,
      tree: displayTree,
      help: showHelp,
      clear: clearScreen,
      b22: () => {
        return null;
      },
      theme: ([arg]) => {
        if (!arg) {
          return 'Available themes: ' + Object.keys(THEMES).join(', ') +
            '\nUsage: theme [name]';
        }
        if (!THEMES[arg]) {
          return `Unknown theme "${arg}". Try: ` + Object.keys(THEMES).join(', ');
        }
        setTheme(arg);
        return `Theme set to "${arg}".`;
      },
      music: () => {
        let list = PLAYLIST.map(
          (track, i) => (currentMusicIndex === i && audio && !audio.paused ? "▶ " : "  ") + (i + 1) + ". " + track.name
        ).join('\n');
        return (
          "Playlist:\n" +
          list +
          "\n\nUse :\n- play [n]\n- pause\n- resume"
        );
      },
      play: ([arg]) => {
        if (!arg || !/^\d+$/.test(arg)) return "use : play [n]";
        let idx = parseInt(arg, 10) - 1;
        if (idx < 0 || idx >= PLAYLIST.length) return "Music not valid.";
        if (audio) {
          audio.pause();
          audio.currentTime = 0;
        }
        audio = new Audio(PLAYLIST[idx].src);
        audio.play();
        currentMusicIndex = idx;
        return `Lecture : ${PLAYLIST[idx].name}`;
      },
      pause: () => {
        if (audio && !audio.paused) {
          audio.pause();
          return "Music paused.";
        }
        return "No music currently.";
      },
      resume: () => {
        if (audio && audio.paused) {
          audio.play();
          return "Music resumed.";
        }
        return "No music to resume.";
      },
    };

    function executeCommand(line) {
      const trimmed = line.trim();
      if (!trimmed) return '';
      const [cmd, ...args] = trimmed.split(/\s+/);
      if (cmd === 'b22') {
        const ascii =
`░▒▓█▓▒         ░▒▓███████▓▒░  ░▒▓███████▓▒░  
░▒▓█▓▒                ░▒▓█▓▒░        ░▒▓█▓▒░ 
░▒▓█▓▒                ░▒▓█▓▒░        ░▒▓█▓▒░ 
░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓██████▓▒░  
░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░        ░▒▓█▓▒░        
░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░        ░▒▓█▓▒░        
░▒▓███████▓▒░  ░▒▓████████▓▒░ ░▒▓████████▓▒░`;

        addToHistory(trimmed, '');
        printAsciiLetterByLetter(ascii);
        return '';
      }

      if (commands[cmd]) {
        try { return commands[cmd](args); }
        catch { return `${cmd}: error executing command`; }
      }
      return `${cmd}: command not found`;
    }

    function updatePrompt() {
      prompt.textContent = `deus@machina:/${currentPath.join('/')}$ `;
    }

    function addToHistory(command, output) {
      const cmdDiv = document.createElement('div');
      cmdDiv.innerHTML = `<span class="prompt">${prompt.textContent}</span><span class="command">${command}</span>`;
      historyDiv.appendChild(cmdDiv);
      if (output) {
        const outDiv = document.createElement('div');
        outDiv.className = 'output';
        outDiv.innerHTML = output;
        historyDiv.appendChild(outDiv);
      }
      historyContainer.scrollTop = historyContainer.scrollHeight;
    }

    let autocompleteState = {
      fragment: '',
      context: '',
      matches: [],
      index: 0,
      lastValue: ''
    };

    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        const command = input.value.trim();
        if (command) {
          commandHistory.push(command);
          localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
          historyIndex = commandHistory.length;
          const output = executeCommand(command);
          if (command !== 'clear') addToHistory(command, output);
          else clearScreen();
          input.value = '';
        }
        autocompleteState = { fragment: '', context: '', matches: [], index: 0, lastValue: '' }; // reset
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) input.value = commandHistory[--historyIndex];
        autocompleteState = { fragment: '', context: '', matches: [], index: 0, lastValue: '' };
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) input.value = commandHistory[++historyIndex];
        else { historyIndex = commandHistory.length; input.value = ''; }
        autocompleteState = { fragment: '', context: '', matches: [], index: 0, lastValue: '' };
      }
      else if (e.key === 'Tab') {
        e.preventDefault();

        const value = input.value;
        const split = value.trim().split(/\s+/);

        if (split.length === 1) {
          const fragment = split[0];
          if (!fragment) return;
          if (
            autocompleteState.context !== 'command' ||
            autocompleteState.fragment !== fragment ||
            autocompleteState.lastValue !== value
          ) {
            autocompleteState.context = 'command';
            autocompleteState.fragment = fragment;
            autocompleteState.matches = Object.keys(commands).filter(cmd => cmd.startsWith(fragment));
            autocompleteState.index = 0;
            autocompleteState.lastValue = value;
          }
          const matches = autocompleteState.matches;
          if (matches.length === 0) return;
          input.value = matches[autocompleteState.index] + ' ';
          autocompleteState.index = (autocompleteState.index + 1) % matches.length;
          autocompleteState.lastValue = input.value;
        }
        else if (split.length >= 2) {
          const cmd = split[0];
          if (cmd === 'cat') {
            const partial = split[1];
            let dir = getCurrentDir();
            if (!dir) return;
            const files = Object.entries(dir)
              .filter(([k, v]) => typeof v !== 'object')
              .map(([k, v]) => k);
            if (
              autocompleteState.context !== 'cat' ||
              autocompleteState.fragment !== partial ||
              autocompleteState.lastValue !== value
            ) {
              autocompleteState.context = 'cat';
              autocompleteState.fragment = partial;
              autocompleteState.matches = files.filter(f => f.startsWith(partial));
              autocompleteState.index = 0;
              autocompleteState.lastValue = value;
            }
            const matches = autocompleteState.matches;
            if (matches.length === 0) return;
            input.value = cmd + ' ' + matches[autocompleteState.index];
            autocompleteState.index = (autocompleteState.index + 1) % matches.length;
            autocompleteState.lastValue = input.value;
          }
        }
      }
    });

    document.addEventListener('click', () => input.focus());
    window.addEventListener('load', () => input.focus());
    updatePrompt();
  </script>
</body>
</html>
